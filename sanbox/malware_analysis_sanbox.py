import os
import hashlib
import subprocess
import time
import logging
from datetime import datetime
import psutil
import socket
import json
import shutil
from pathlib import Path

# Configuration - using relative paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
LOG_DIR = os.path.join(SCRIPT_DIR, "logs")
SANDBOX_DIR = os.path.join(SCRIPT_DIR, "sandbox")
SAMPLE_DIR = os.path.join(SCRIPT_DIR, "samples")
REPORT_DIR = os.path.join(SCRIPT_DIR, "reports")
SNAPSHOT_DIR = os.path.join(SCRIPT_DIR, "snapshots")

# Create all required directories
Path(LOG_DIR).mkdir(parents=True, exist_ok=True)
Path(SANDBOX_DIR).mkdir(parents=True, exist_ok=True)
Path(SAMPLE_DIR).mkdir(parents=True, exist_ok=True)
Path(REPORT_DIR).mkdir(parents=True, exist_ok=True)
Path(SNAPSHOT_DIR).mkdir(parents=True, exist_ok=True)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(LOG_DIR, 'sandbox.log')),
        logging.StreamHandler()
    ]
)

class SimpleFileMonitor:
    def __init__(self, directory):
        self.directory = directory
        self.initial_state = self.get_directory_state()
        
    def get_directory_state(self):
        """Get current state of the directory"""
        state = {
            'files': set(),
            'contents': {}
        }
        for root, _, files in os.walk(self.directory):
            for file in files:
                path = os.path.join(root, file)
                state['files'].add(path)
                try:
                    with open(path, 'rb') as f:
                        state['contents'][path] = hashlib.sha256(f.read()).hexdigest()
                except Exception:
                    state['contents'][path] = None
        return state
    
    def detect_changes(self):
        """Detect changes since initialization"""
        current_state = self.get_directory_state()
        changes = {
            'created': list(current_state['files'] - self.initial_state['files']),
            'deleted': list(self.initial_state['files'] - current_state['files']),
            'modified': []
        }
        
        for path in self.initial_state['files'] & current_state['files']:
            if path in self.initial_state['contents'] and path in current_state['contents']:
                if self.initial_state['contents'][path] != current_state['contents'][path]:
                    changes['modified'].append(path)
        
        return changes

class MalwareSandbox:
    def __init__(self):
        self.system_state_before = None
        self.system_state_after = None
        self.behavior_log = []
        
    def calculate_file_hash(self, file_path):
        """Calculate SHA256 hash of a file"""
        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            while chunk := f.read(4096):
                sha256.update(chunk)
        return sha256.hexdigest()
    
    def take_system_snapshot(self):
        """Record system state before execution"""
        snapshot = {
            "timestamp": datetime.now().isoformat(),
            "running_processes": [],
            "network_connections": [],
            "open_files": [],
            "file_system": {}
        }
        
        # Record processes
        for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline']):
            snapshot["running_processes"].append(proc.info)
        
        # Record network connections
        for conn in psutil.net_connections():
            snapshot["network_connections"].append({
                "fd": conn.fd,
                "family": conn.family,
                "type": conn.type,
                "laddr": conn.laddr,
                "raddr": conn.raddr,
                "status": conn.status,
                "pid": conn.pid
            })
        
        # Record open files
        for proc in psutil.process_iter(['pid', 'open_files']):
            if proc.info['open_files']:
                snapshot["open_files"].append(proc.info)
        
        return snapshot
    
    def monitor_file_changes(self):
        """Monitor file system changes during execution"""
        monitor = SimpleFileMonitor(SANDBOX_DIR)
        time.sleep(1)  # Small delay before checking changes
        changes = monitor.detect_changes()
        
        for created in changes['created']:
            self.log_behavior(f"File created: {created}")
        
        for deleted in changes['deleted']:
            self.log_behavior(f"File deleted: {deleted}")
        
        for modified in changes['modified']:
            self.log_behavior(f"File modified: {modified}")
    
    def log_behavior(self, message):
        """Log suspicious behavior"""
        timestamp = datetime.now().isoformat()
        self.behavior_log.append(f"{timestamp} - {message}")
        logging.info(message)
    
    def analyze_sample(self, sample_path):
        """Analyze a malware sample"""
        if not os.path.exists(sample_path):
            raise FileNotFoundError(f"Sample not found: {sample_path}")
        
        sample_hash = self.calculate_file_hash(sample_path)
        report = {
            "sample_path": sample_path,
            "sample_hash": sample_hash,
            "analysis_start": datetime.now().isoformat(),
            "behaviors": [],
            "system_changes": {}
        }
        
        try:
            # Prepare sandbox
            sandbox_sample_path = os.path.join(SANDBOX_DIR, os.path.basename(sample_path))
            shutil.copy(sample_path, sandbox_sample_path)
            
            # Take pre-execution snapshot
            self.system_state_before = self.take_system_snapshot()
            
            # Execute sample in isolated environment
            self.log_behavior(f"Executing sample: {sample_path}")
            process = subprocess.Popen(
                sandbox_sample_path,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=SANDBOX_DIR,
                shell=True
            )
            
            # Monitor for 60 seconds
            time.sleep(60)
            
            # Terminate if still running
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
                self.log_behavior("Sample was terminated after timeout")
            
            # Take post-execution snapshot
            self.system_state_after = self.take_system_snapshot()
            
            # Check for file changes
            self.monitor_file_changes()
            
            # Compare system states
            report["system_changes"] = self.compare_system_states()
            report["behaviors"] = self.behavior_log
            report["analysis_end"] = datetime.now().isoformat()
            
            # Save report
            report_filename = f"report_{sample_hash}.json"
            report_path = os.path.join(REPORT_DIR, report_filename)
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)
            
            self.log_behavior(f"Analysis complete. Report saved to {report_path}")
            return report_path
            
        except Exception as e:
            self.log_behavior(f"Error during analysis: {str(e)}")
            raise
        
        finally:
            # Clean up
            if os.path.exists(sandbox_sample_path):
                os.remove(sandbox_sample_path)
    
    def compare_system_states(self):
        """Compare system states before and after execution"""
        changes = {
            "new_processes": [],
            "terminated_processes": [],
            "new_network_connections": [],
            "file_system_changes": []
        }
        
        # Compare processes
        before_pids = {p['pid'] for p in self.system_state_before['running_processes']}
        after_pids = {p['pid'] for p in self.system_state_after['running_processes']}
        
        changes["new_processes"] = [
            p for p in self.system_state_after['running_processes'] 
            if p['pid'] not in before_pids
        ]
        
        changes["terminated_processes"] = [
            p for p in self.system_state_before['running_processes'] 
            if p['pid'] not in after_pids
        ]
        
        # Compare network connections (simplified)
        changes["new_network_connections"] = [
            conn for conn in self.system_state_after['network_connections']
            if conn not in self.system_state_before['network_connections']
        ]
        
        return changes

if __name__ == "__main__":
    sandbox = MalwareSandbox()
    print("Malware Sandbox initialized")
    
    # Example usage
    sample_path = input("Enter path to malware sample: ").strip('"')
    if os.path.exists(sample_path):
        print(f"Analyzing sample: {sample_path}")
        report_path = sandbox.analyze_sample(sample_path)
        print(f"Analysis complete. Report saved to: {report_path}")
    else:
        print("Sample file not found.")